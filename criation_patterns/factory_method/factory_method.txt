FACTORY METHOD PATTERN

PORQUE PRECISAMOS
    
    QUANDO ESTAMOS FAZENDO UM PROGRAMA ORIENTADO A OBJETOS, IREMOS EM ALGUM MOMENTO PRECISAR INSTANCIAR OS OBJETOS, ISTO É INEVITÁVEL, ENTÃO UMA MANEIRA MAIS ORGANIZADA DE SE FAZER ISSO, SERIA "COBRIR" A INSTACIAÇÃO DESSES OBJETOS COM UMA FÁBRICA(FACTORY) E ENTÃO ESSA FÁBRICA SER RESPONSÁVEL PELA INSTANCIAÇÃO DOS OBJETOS, A PRIMEIRA VISTA ISSO PODE PARECER SEM SENTIDO, POIS QUANDO ESCUTAMOS ISSO PELA PRIMEIRA VEZ PODEMOS PENSAR "ORA, MAS VAMOS APENAS SUBSTITUIR O "NEW" POR ALGUM MÉTODO "CREATE" DA CLASSE FÁBRICA QUE VAI ME RETORNAR A INSTÂNCIA". CERTO, A PRIMEIRA VISTA PARECE ISSO MESMO, MAS VEJA ESSAS DUAS SITUAÇÕES NAS QUAIS UMA "FÁBRICA" PODE SER UTIL:
    A --> QUANDO A INSTANCIAÇÃO DO OBJETO NÃO PODE SER FEITA APENAS EM UMA LINHA
          AS VEZES É PRECISO CUMPRIR ALGUMAS REGRAS DE NEGÓCIO, OU SEJA,
          PRECISAMOS FAZER ALGUM TIPO DE COMPUTAÇÃO, DESSA MANEIRA ESTAMOS 
          ENCAPSULANDO ESSE CÓDIGO.
    B --> A FÁBRICA NOS PERMITE POLIMORFISMO NO QUE DIZ RESPEITO A PRÓPRIA
          FÁBRICA

LÓGICA 
    VAMOS TENTAR FALAR DE MANEIRA BEM RESUMIDA, MAS IMAGINE QUE ESTAMOS CRIANDO UM PROGRAMA DE COMPUTAÇÃO GRÁFICA QUE VAI RENDERIZAR UMA FLORESTA ALEATORIAMENTE, ASSIM NÓS NÃO SABEMOS OQUE QUEREMOS CRIAR EM ESPECIFICO APENAS CHAMAR UMA CLASSE QUE ME DEVOLVA UM ANIMAL, UM ÁRVORE OU UM LAGO, TANTO FAZ, APENAS QUEREMOS RENDERIZAR O MUNDO CONFORME O JOGADOR ANDAR POR ELE, COMO NOS JOGOS DA ROCKSTAR, MAS OBVIAMENTE BEM MAIS MAL FEITO DO QUE ELES HAHA.
    PORTANTO, NÓS NÃO QUEREMOS ADICIONAR MAIS LINHAS DE CÓDIGO PARA DECIDIR QUAL OBJETO SERÁ INSTANCIADO NA PARTE DO CÓDIGO ONDE A CHAMADA PARA ESTES OBJETOS (CACHORRO, ÁRVORE, LAGO, CERVO, ETC) SÃO FEITAS, APENAS QUEREMOS CHAMAR E QUE APAREÇA ALGUMA COISA NA NOSSA FLORESTA E É AI QUE ENTRA O PADRÃO DA FÁBRICA.
    A NOSSA FÁBRICA VAI ENCAPSULAR TODA A LÓGICA DE DECISÃO DE QUAL OBJETO RETORNAR, ENTÃO AO INVÉS DE FICAR INSTANCIANDO VÁRIOS OBJETOS DIFERENTES, PODEMOS CRIAR UMA FÁBRICA QUE IRÁ CONTER A LÓGICA DE DECISÃO E SEMPRE QUE CHAMARMOS ELA, ELA IRÁ NOS RETORNAR UM OBJETO QUALQUER A PARTIR DA LÓGICAS QUE NÓS DESCREVEMOS.
    DE MANEIRA UM POUCO MAIS DETALHADA, IMAGINE QUE NO NOSSO PROGRAMA EXISTA UM CLASSE ABSTRATA ANIMAL, COM VÁRIAS SUBCLASSES DE ESPÉCIES DE ANIMAIS E ENTÃO CONFORME ANDAMOS PELA FLORESTA QUEREMOS QUE APAREÇA ANIMAIS DIFERENTES PELO ESPAÇO, DESTE MODO, PODEMOS CRIAR UMA CLASSE CHAMADA DE "RANDOM_FACTORY" (OU "FÁBRICA_ALEATÓRIA" EM PORTUGUÊS) E NELA VAI ESTAR CONTIDA TODA A LÓGICA QUE DECIDE QUAL ANIMAL RETONAR, ASSIM TODA VEZ QUE CHAMARMOS ELA, ELA VAI RETORNAR UM ANIMAL ALEATÓRIO E VAMOS COLOCAR NO CENÁRIO. VALE LEMBRAR QUE A RANDOM_FACTORY É UMA SUBCLASSE DE UMA "ANIMAL_FACTORY".

A DEFINIÇÃO
    SEGUNDO O LIVRO DE PADRÕES DE PROJETO GANG OF FOUR: "Definir uma interface para criar um objeto, mas deixar as subclasses decidirem que classe instanciar. O Factory Method permite adiar a instanciação para subclasses."
    LEMBRANDO QUE QUANDO FALAMOS INTERFACE, ESTAMOS NO REFERINDO MAIS COMO UM "CONTRATO" QUE PRECISA SER SEGUIDO E NÃO NECESSARIAMENTE UMA INTERFACE EM SI, PODE SER TANTO UM INTERFACE QUANTO UMA SUPERCLASSE.
    ASSIM NESSE NOSSO MÉTODO NÓS NÃO SABEMOS COMO IREMOS CRIAR OS NOSSOS OBJETOS OU QUANDO CRIAR OU QUE PARÂMETROS VAMOS PASSAR PARA A CRIAÇÃO, ENTÃO É POR ESSE MOTIVO QUE A DEFINIÇÃO FALA "O Factory Method permite adiar a instanciação para subclasses". (HONESTAMENTE, A DEFINIÇÃO DO PADRÃO É BEM CONFUSA KK) 
    VAMOS OLHAR NA IMAGEM "pattern_structure.jpg" E TENTAR COMPARAR COM O NOSSO EXEMPLO, NELA NÓS TEMOS:
    O PRODUCT          --> ESSE SERIA O NOSSO ANIMAL    
    O CREATOR          --> ESSE SERIA A NOSSA ANIMAL_FACTORY
    O CONCRETE_PRODUCT --> NOSSOS GATOS, CACHORROS, CERVOS, ETC (SÃO PRODUCTS)
    O CONCRETE_CREATOR --> ESSE SERIA A NOSSA RANDOM_FACTORY (SÃO CREATORS).


AGORA VAMOS TENTAR IMPLEMENTAR UM SIMPLIFICAÇÃO DA NOSSA FLORESTA
OLHE O ARQUIVO "factory_method.cpp"














    
